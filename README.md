# java-treasure

关于数据结构、各类算法、Java多线程的学习过程和各大企业面试题的一些整理

# 知识点整理

## 基本概念

### 操作系统中 heap（堆） 和 stack（栈） 的区别

答：

* 栈由操作系统自动分配释放，一般用来存放函数的参数值、局部变量；堆由程序自己申请释放，一般用来存放类变量和实例变量，若不释放则程序结束时由操作系统回收。
* 栈使用的是一级缓存，被调用时处于存储空间中，调用完自动释放；堆使用的是二级缓存，生命周期由虚拟机的垃圾回收算法决定。
* 堆的数据结构类似树，而栈是先进先出的数据结构。
	
### 什么是基于注解的切面实现
答：<br/>
通过注解在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的实现。

### 什么是 对象/关系 映射集成模块
答：<br/>
对象关系映射（Object Relational Mapping，简称ORM）是通过使用描述对象和数据库之间映射的元数据，将面向对象语言程序中的对象自动持久化到关系数据库中。本质上就是将数据从一种形式转换到另外一种形式。


### 什么是 Java 的反射机制
答：<br/>
反射是一种计算机处理方式。有程序可以访问、检测和修改它本身状态或行为的这种能力。能提供封装程序集、类型的对象。（程序集包含模块，而模块包含类型，类型又包含成员。）
反射机制指的是程序在运行时能够获取自身的信息。在java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息。    

优点：

* 反射提高了程序的灵活性和扩展性。 
* 降低耦合性，提高自适应能力。 
* 它允许程序创建和控制任何类的对象，无需提前硬编码目标类。

缺点：

* 性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。 
* 使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。

### 什么是 ACID
答：

* Atomicity 原子性 任务是一个独立的操作单元。
* Consistency 一致性 一个事务可以封装状态改变，事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。
* Isolation 隔离性 事务是并发控制机制，一个失败的事务不应该破坏系统的状态。
* Durability 持久性 一个成功的事务将永久性地改变系统的状态，所以在它结束之前，所有导致状态的变化都记录在一个持久的事务日志中。

### BS与CS的联系与区别
答：<br/>
Client/Server，服务器通常采用高性能的PC、工作站或小型机，客户端需要安装专用的客户端软件。
Brower/Server，客户机上只要安装一个浏览器，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现。
区别：

* 硬件环境，C/S 一般建立在专用的网络上，小范围里的网络环境，B/S 建立在广域网之上的，不必是专门的网络硬件环境，只要有操作系统和浏览器就行。<br/>
* 安全要求，C/S 一般面向相对固定的用户群，对信息安全的控制能力很强。B/S 建立在广域网之上，对安全的控制能力相对弱，可能面向不可知的用户。 
* 程序架构，C/S 程序可以更加注重流程，可以对权限多层次校验， 对系统运行速度可以较少考虑。B/S 对安全以及访问速度的多重的考虑，建立在需要更加优化的基础之上。

### Cookie 和 Session的区别
答：<br/>
Cookie是访问某些网站以后在本地存储的一些网站相关的信息，下次再访问的时候减少一些步骤。另外一个更准确的说法是：Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器，是一种在客户端保持状态的方案。主要内容包括：名字，值，过期时间，路径和域。

Session是存在服务器的一种用来存放用户数据的类HashTable结构。当浏览器 第一次发送请求时，服务器自动生成了一个HashTable和一个Session ID用来唯一标识这个HashTable，并将其通过响应发送到浏览器。当浏览器第二次发送请求，会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的HashTable。

区别：

* 一个在客户端一个在服务端。
* Session过多的时候会消耗服务器资源，所以大型网站会有专门的Session服务器，而Cookie存在客户端所以没什么问题。
* 域的支持范围不一样，比方说a.com的Cookie在a.com下都能用，而www.a.com的Session在api.a.com下都不能用，解决这个问题的办法是JSONP或者跨域资源共享。

### fail-fast 与 fail-safe 机制有什么区别
答：<br/>
fail-fast：在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。java.util下都是快速失败。

fail-safe：采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历，上层集合的变化不会影响下层的遍历。java.util.concurrent下都是安全失败。

### get 和 post请求的区别
答：

* get参数通过url传递，post放在request body中。
* get请求在url中传递的参数是有长度限制的，而post没有。
* get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。
* get请求只能进行url编码，而post支持多种编码方式。
* get请求会浏览器主动cache，而post不会。
* get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。
* GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。
* GET产生一个TCP数据包；POST产生两个TCP数据包。

### Interface 与 abstract 类的区别
答：

* 在接口中，所有方法都是抽象，公开的；在抽象类中方法可以可以没有抽象方法。<br/>
* 接口中的所有方法都没有方法体；抽象类中的方法可以有方法体，只有抽象方法没有方法体。<br/>
* 一个类可以实现多个接口；但一个类只能继承一个抽象类。<br/>
* 接口强调特定功能的实现；而抽象类强调所属关系。 <br/>
* 接口中的方法在实现类中必须全部实现；二抽象类中的方法子类只需要实现父类的抽象方法，非抽象方法可以覆盖。<br/>

### IOC的优点是什么
答：<br/>
IOC即反转控制，或依赖注入。就是把底层类作为参数传入上层类，实现上层类对下层类的“控制”。将对象的生成从程序中移出，放到统一的XML文件中管理。在创建实例的时候不需要了解其中的细节。第一，资源集中管理，实现资源的可配置和易管理。第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度，提高程序的灵活性和可维护性。

### IO 和 NIO的区别，NIO优点
答：

* IO是面向流的，NIO是面向缓冲区的。IO每次从流中读取一个字节或多个字节，知道读取完所有字节，无任何缓存，也不能前后移动流中的数据；NIO读取数据的时候会先存入一个缓冲区，稍后再处理，可以在缓冲区前后移动，从而增加了处理的灵活性。
* IO的各种流是阻塞的，NIO是非阻塞模式（异步IO）的。当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入，该线程在此期间不能再干任何事情了；而NIO中一个线程在读取数据时不需要等待它完全读完，同时可以执行其他任务。
* Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。<br/>

### Java 9 / Java 8 / Java 7 为我们提供了什么新功能
答：
Java 9：

* HTTP/2，
* JShell（让Java也可以像脚本语言一样来运行，可以从控制台启动 jshell）
* 不可变集合工厂方法
* 私有接口方法
* HTML5风格的Java帮助文档

### 什么是竞态条件？ 举个例子说明。
答：<br/>
多线程同时访问同一个资源，如果对访问顺序敏感，就会出现竞态条件。
例：

	class Counter { 
	    protected long count = 0; 
	    public void add(long value) { 
	        this.count = this.count + value; 
	    } 
	} 
	
A和B交错执行，两个线程分别加了2和3到count变量上，两个线程执行结束后count变量的值应该等于5。最终的值并不是期望的5，而是最后写回内存的那个线程的值

### JRE、JDK、JVM 及 JIT 之间有什么不同
答：

* JRE(Java运行时环境)，是JVM的一个超集，是运行基于Java语言编写的程序所不可缺少的运行环境。没有包含任何开发工具（如编译器和调试器） 
* JDK(Java开发工具箱)，是编写一个java应用所需要的所有jar文件和可执行文件，是整个Java的核心，包括了Java运行环境JRE、Java工具和Java基础类库。
* JVM(Java虚拟机)，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行。class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。
* JIT(即时编译器)，通过有效的把字节码变成机器码来提高JVM的效率。当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被准换为本地代码，这样有利大幅度提高 Java 应用的性能。

### MVC的各个部分都有那些技术来实现?如何实现?
答：

* Model模型 JavaBean、EJB、SpringBean<br/>
* View视图 JSP、Vuejs、Angular、Reactjs、Emberjs<br/>
* Control控制 Servlet、RestController<br/>

### RPC 通信和 RMI 区别
答：<br/>
RPC（远程过程调用）、RMI（远程方法调用）<br/>

* 方法调用方式不同：RMI中是通过在客户端的Stub对象作为远程接口进行远程方法的调用。每个方法都具有签名。如果一个方法在服务器上执行，但是没有相匹配的签名被添加到这个远程接口(stub)上，那么这个新方法就不能被RMI客户方所调用。而RPC是通过网络服务协议向远程主机发送请求，请求包含了一个参数集和一个文本值，RPC远程主机就去搜索与之相匹配的类和方法，找到后就执行方法并把结果编码，通过网络协议发回。
* 适用语言范围不同：RMI只用于Java；RPC是网络服务协议，与操作系统和语言无关。
* 调用结果的返回形式不同：RPC 不支持对象， 采用http协议；RMI支持传输对象。采用tcp／ip 协议

### 什么是 Web Service（Web服务）
答：<br/>
一种跨编程语言和跨操作系统平台的远程调用技术。

一个Web服务就是一个能够使用XML消息通过网络来访问的接口，这个接口描述了一组可访问的操作，可与其他基于XML消息的应用程序交互。融合了以组件为基础的开发模式和 Web 的出色性能，既是软件又是应用程序集成的平台。具有分布式、松散藕合、可复用性、开放性以及可交互性等特性。

Web Service = XML+XSD,SOAP（简单对象访问协议）和WSDL（网络服务描述语言）

### WEB容器主要有哪些功能? 并请列出一些常见的WEB容器名字
答：<br/>
功能：给处于其中的应用程序组件提供一个环境，使它们直接跟容器中的环境变量交互，不必关注其它系统问题。
Tomcat、IIS、Apache、WebLogic

### JSWDL开发包的介绍。JAXP、JAXM的解释，SOAP、UDDI、WSDL解释
答：

* JAXP：(Java API for XML Parsing) 定义了在Java中使用DOM, SAX, XSLT的通用的接口。这样在你的程序中你只要使用这些通用的接口，当你需要改变具体的实现时候也不需要修改代码。
* JAXM：(Java API for XML Messaging) 是为SOAP通信提供访问方法和传输机制的API。
* SOAP：(Simple Object Access Protocol) 简单对象传输协议，它是用于交换XML编码信息的轻量级协议。
UDDI： 目的是为电子商务建立标准；UDDI是一套基于Web的、分布式的、为Web Service提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web Service注册，以使别的企业能够发现的访问协议的实现标准。
* WSDL： 是一种 XML 格式，用于将网络服务描述为一组端点，这些端点对包含面向文档信息或面向过程信息的消息进行操作。这种格式首先对操作和消息进行抽象描述，然后将其绑定到具体的网络协议和消息格式上以定义端点。相关的具体端点即组合成为抽象端点（服务）。

### 一个".java"源文件中是否可以包含多个类（不是内部类）？有什么限制
答：<br/>
一个“.java”源文件里面可以包含多个类，但是只允许有一个public类，并且类名必须和文件名一致。

### 简单说说你了解的类加载器。是否实现过类加载器
答：<br/>
虚拟机设计团队把类加载阶段中“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的模块称为“类加载器”。

JVM把描述类数据的字节码.Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机的类加载机制。

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的生命周期包括了：加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸载(Unloading)七个阶段，其中验证、准备、解析三个部分统称链接。
### 解释一下什么叫AOP（面向切面编程）
答：<br/>
在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。

### 请简述 Servlet 的生命周期及其相关的方法
答：<br/>
Servlet 生命周期：Servlet 加载--->实例化--->服务--->销毁。

init（）：在Servlet的生命周期中，仅执行一次init()方法。它是在服务器装入Servlet时执行的，负责初始化Servlet对象。可以配置服务器，以在启动服务器或客户机首次访问Servlet时装入Servlet。无论有多少客户机访问Servlet，都不会重复执行init（）。

service（）：它是Servlet的核心，负责响应客户的请求。每当一个客户请求一个HttpServlet对象，该对象的Service()方法就要调用，而且传递给这个方法一个“请求”（ServletRequest）对象和一个“响应”（ServletResponse）对象作为参数。在HttpServlet中已存在Service()方法。默认的服务功能是调用与HTTP请求的方法相应的do功能。

destroy（）： 仅执行一次，在服务器端停止且卸载Servlet时执行该方法。当Servlet对象退出生命周期时，负责释放占用的资源。一个Servlet在运行service()方法时可能会产生其他的线程，因此需要确认在调用destroy()方法时，这些线程已经终止或完成。

### 请简述一下 Ajax 的原理及实现步骤
答：<br/>
Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。

* 创建XMLHttpRequest对象(需要考虑各浏览器兼容的问题)
* 使用XMLHttpRequest对象打开一个连接(指定连接方式<post/get>和连接地址以及是否同步);调用XMLHttpRequest对象的open方法。第一个参数是提交数据的方式，取值为post/get；第二个参数是提交的目标页面(也就是用于处理提交数据的页面)；第三个参数指定是否请求是异步的-缺省值为true，为了发送一个同步请求，需要把这个参数设置为false。
* 设置请求的头部(请求的类型和请求的编码格式)
* 设置回调函数，主要用于处理从服务端发送给客户端的数据，主要使用javascript去调用页面中的元素，并根据服务端返回的结果去控制页面中元素的更新。内部实现实际上是javascript中的事件处理机制。
* 发送请求:调用XMLHttpRequest对象的send方法实现数据的发送。
* 更新页面显示

### 什么是 N 层架构
答：<br/>
多层式运行架构，最简单的N层架构就是三层架构，它包括表现层、应用层、数据层。表现层用于用户接口的展示，以及用业务层的类和对象来“驱动”这些接口。业务层用于访问数据层，从数据层取数据、修改数据以及删除数据，并将结果返回给表现层。数据层是数据库或者数据源。

优点：扩展性：主要因为多层部署和层之间分离的能力。对于整个系统更好的和更精细的安全控制：我们能根据每层的安全需求不同而进行不同的安全控制。更好的容错能力。单独的层升级或是改变不影响其他的层。对于开发来说比较友好和高效。更好的可重用性。

### 什么是CORBA？用途是什么
答：<br/>
公共对象请求代理结构，分为三个部分：作为分布式对象通信基础设施的对象请求代理ORB的体系结构；接口定义语言IDL的语法和语义以及到各种程序设计语言的映射；保证可互操作性的标准ORB间的通信协议GIOP/IIOP。目的为：用不同的程序设计语言书写在不同的进程中运行，为不同的操作系统开发。

### 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”
答：<br/>
java虚拟机是执行字节码文件（.class）的虚拟机进程。
java源程序（.java）被编译器编译成字节码文件（.class）。然后字节码文件，将由java虚拟机，解释成机器码（不同平台的机器码不同）。

因为不同的平台装有不同的JVM，它们能够将相同的.class文件，解释成不同平台所需要的机器码。正是因为有JVM的存在，java被称为平台无关的编程语言。

### 什么是正则表达式？用途是什么？哪个包使用正则表达式来实现模式匹配
答：<br/>
用一小段简单的各种字符的组合去实现复杂的字符串匹配。用途：1.字符串匹配，2.指定字符串替换，3.指定字符串查找，4.字符串分割。

java.util.regex程序包,它包括两个类：Pattern和Matcher。

### 什么是懒加载（Lazy Loading）
答：<br/>
延迟加载，什么时候使用什么时候开辟空间，不用的时候只是一个指针不占用内存，当使用的时候为其alloc/init，这时候才占用内存。只要不使用就永远不会真正生成，不会占用空间。

### 什么是尾递归，为什么需要尾递归
答：<br/>
尾递归是指所有递归形式的调用，一定是发生在函数的末尾。形式上只要最后一个return语句是单纯函数就可以。

尾递归和一般的递归不同在对内存的占用，普通递归创建stack累积而后计算收缩，尾递归只会占用恒量的内存（和迭代一样）。通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。

### 什么是控制反转（Inversion of Control）与依赖注入（Dependency Injection）
答：<br/>
把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。

## 关键字
### finalize
#### 什么是finalize()方法?

* finalize()方法什么时候被调用?

答：在垃圾回收器执行时会调用被回收对象的finalize()方法

* 析构函数(finalization)的目的是什么?

答：用来释放被对象占用的资源。

* final 和 finalize 的区别?

答：final关键字可以用于类，方法，变量前，用来表示该关键字修饰的类，方法，变量具有不可变的特性；<br/>
finalize方法来自于java.lang.Object，用于回收资源。可以为任何一个类添加finalize方法。finalize方法将在垃圾回收器清除对象之前调用。

#### final关键字有哪些用法

* final 与 static 关键字可以用于哪里？它们的作用是什么

答：final关键字可以用于类，方法，变量前，用来表示该关键字修饰的类，方法，变量具有不可变的特性；
被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。static可以用来修饰类的成员方法、类的成员变量，另外可以编写static代码块来优化程序性能。

* final, finally, finalize的区别

答：finally是在异常处理时提供finally块来执行任何清除操作。不管有没有异常被抛出、捕获，finally块都会被执行。

#### 能否在运行时向 static final 类型的赋值

* 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变

答：使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。 

* 一个类被声明为final类型，表示了什么意思

答：不终极类，能被继承，没有子类，final类中的方法默认是final的。final成员变量表示常量，只能被赋值一次，赋值后值不再改变。final不能用于修饰构造方法，不能既被声明为 abstract的。

* throws, throw, try, catch, finally分别代表什么意义

答：throws用于在方法签名中声明抛出一个或多个异常类，throws关键字后可以紧跟一个或多个异常类。<br/>
&nbsp;&nbsp;throw用于手动地抛出异常对象。throw后面需要一个异常对象。<br/>
&nbsp;&nbsp;try块表示程序正常的业务执行代码。如果程序在执行try块的代码时出现了“非预期”情况，JVM将会生成一个异常对象，这个异常对象将会被后面相应的catch块捕获。<br/>
&nbsp;&nbsp;catch块表示一个异常捕获块。当程序执行try块引发异常时，这个异常对象将会被后面相应的catch块捕获。<br/>
&nbsp;&nbsp;finally块代表异常处理流程中总会执行的代码块。

### Java 有几种修饰符？分别用来修饰什么

答：

* public公共访问控制符，修饰公共域，可以被所有其它类所引用。
* protected保护访问控制符，允许其它包中它的子类来访问父类的特定属性。
* private私有访问控制符，修饰该类本身或该类的子类两种类访问和引用。
* static静态域修饰符，修饰仅属于类的变量，不属于任何一个具体的实例。
* final最终类修饰符，定义符号常量的，取值在程序的整个执行过程中都是不变的。
* volatile共享域修饰符，用来说明这个成员变量可能被几个线程所控制和修改。
* transient暂时性域修饰符，用来定义一个暂时性变量，将指定 Java虚拟机认定该暂时性变量不属于永久状态。只能修饰变量，而不能修饰方法和类阻止实例中那些用此关键字声明的变量持久化。
* native本地方法控制符，说明其修饰的方法是一个原生态方法，为了提高程序的运行速度，需要用其它的高级语言书写程序的方法体。
* synchronized同步方法控制符，用于多线程共存的程序中的协调和同步。

### volatile
#### volatile 修饰符的有过什么实践

* volatile 变量是什么？volatile 变量和 atomic 变量有什么不同

答：告诉程序，该变量是易变的，不稳定的，每次必须去主存读取，而不要从自己的缓存中获取副本。不同：volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。atomic，操作原子性，还是属性声明关键字中默认值， 经过atomic 修饰的变量count，仅仅只是在getter和setter的时候是原子操作。

* volatile 类型变量提供什么保证？能使得一个非原子操作变成原子操作吗

答：volatile关键字确保了应用中的可视性。如果你将一个域声明为volatile，那么只要这个域产生了写操作，那么所有的读操作就都可以看到这个修改。不能。

* 能创建 volatile 数组吗？

答：可以，创建的是一个指向数组的引用，改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。

### transient变量有什么特点
答：transient是类型修饰符，只能用来修饰字段。在对象序列化的过程中，标记为transient的变量不会被序列化。
一个静态变量不管是否被transient修饰，均不能被序列化。
### super什么时候使用
答：super可以理解为是指向自己父类对象的一个指针，而这个超类指的是离自己最近的一个父类。调用父类中的某一个构造函数，如果父类的构造函数是无参的，那子类构造函数会在第一行默认调用super()。引用父类的成员方法或变量。用super()必须写在子类构造方法的第一行，否则编译不通过。
### public static void 写成 static public void会怎样
答：不会影响程序正常运行。

### 说明一下public static void main(String args[])这段声明里每个关键字的作用
答：public: main方法是Java程序运行时调用的第一个方法，因此它必须对Java环境可见。所以可见性设置为public.

static: Java平台调用这个方法时不会创建这个类的一个实例，因此这个方法必须声明为static。

void: main方法没有返回值。

String：是命令行传进参数的类型，args：是指命令行传进的字符串数组。

### 请说出作用域public, private, protected, 以及不写时的区别
答：private修饰的成员变量和函数只能在类本身和内部类中被访问。

protected 修饰的成员变量和函数能被类本身、子类及同一个包中的类访问。

public修饰的成员变量和函数可以被类、子类、同一个包中的类以及任意其他类访问。

默认情况（不写）下，属于一种包访问，即能被类本身以及同一个包中的类访问。


### sizeof 是Java 的关键字吗
答：不是

### static
* static class 与 non static class的区别<br/>

答：static修饰的是内部类，此时这个内部类变为静态内部类；不需要有指向外部类的引用；只能访问外部类的静态成员，不能访问外部类的非静态成员；
非静态内部类需要持有对外部类的引用；能够访问外部类的静态和非静态成员；不能脱离外部类实体被创建；可以访问外部类的数据和方法；

* static 关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法

答：仅属于类的变量，不属于任何一个具体的实例。不能覆盖static方法，不能覆盖private方法。

* 静态类型有什么特点

答：static所修饰的方法/变量可以直接通过类名访问，而不需要通过实例进行访问。被static修饰的变量在堆只有一个副本，所有对象对该变量的操作都是在操作同一个变量。

* main() 方法为什么必须是静态的？能不能声明 main() 方法为非静态

答：main方法是程序的主入口，在这之前不可能有任何变量被实例化，所以当然不能使非静态的。

* 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用

答：不可以，非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，当一个static方法被调用时，可能还没有创建任何实例对象。

* 静态变量在什么时候加载？编译期还是运行期？静态代码块加载的时机呢

答：编译期。静态代码块的代码只会在类第一次初始化的时候执行一次。一个类可以有多个静态代码块，它并不是类的成员，也没有返回值，并且不能直接调用。静态代码块不能包含this或者super,它们通常被用来初始化静态变量。

* 成员方法是否可以访问静态变量？为什么静态方法不能访问成员变量

答：成员方法可以访问静态变量，静态方法不能访问成员变量。因为静态方法中访问成员变量等于是使用了this指针，而静态方法是没有this的。同时成员变量是必须要通过实例才能访问的，而静态方法是被类直接访问，此时尚未实例化，成员变量当然不可访问。

### switch

* switch 语句中的表达式可以是什么类型数据

答：只能是一个整数表达式或者枚举常量，整数表达式可以是int类型或Integer包装类型。

* switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上

答：由于，byte，short，char都可以隐式转换为int类型，所以，这些类型也可以用作表达式。jdk7以后，switch表达式也可以为String类型。

### while 循环和 do 循环有什么不同
答：先判断布尔表达式，如果为true就会执行循环体中的语句，然后再判断布尔表达式，如果为true就执行循环体中的语句，一直到布尔表达式为false，然后循环结束。
先执行一次循环体，然后在判断布尔表达式是不是true，如果是就继续执行循环体，在判断布尔表达式，直到为false就结束循环。

两者的区别：while是先判断在执行如果判断不成立，就不会执行；do/while是先执行在判断，不管判断是否成立都会执行一次

## 操作

### &操作符和&&操作符有什么区别?

答：&：表示普通与，所有的判断条件都要依次执行；&&：若干个条件，如果前面的条件返回false,那么后面不再判断，就是false;

### a = a + b 与 a += b 的区别？

答：当a和b类型相同时，结果没有区别，+=执行效率更高。当a和b类型不同时，+=运算结合了强制类型转换的功能，而a=a+b是简单的运算，没有类型转换，在编译过程中会报错。

### 逻辑操作符 (&,|,^)与条件操作符(&&,||)的区别

答：条件操作只能操作布尔型的,而逻辑操作不仅可以操作布尔型,而且可以操作数值型；逻辑操作不会产生短路，所有的判断条件都要依次执行。

### 3*0.1 == 0.3 将会返回什么？true 还是 false？

答：false，浮点数不能完全精确的表示出来.

### float f=3.4; 是否正确？

答：不正确。3.4是double类型的，精度不准确。编译器可以自动向上转型，将精度低的转为精度高的类型，但是float类型精度比double低。

### short s1 = 1; s1 = s1 + 1;有什么错?

答：由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。

## 数据结构

### 基础类型（原生类）

* 基础类型(Primitives)与封装类型(Wrappers)的区别在哪里

答：（1）基本类型只能按值传递，而每个基本类型对应的封装类是按引用传递的。<br/>
（2）java中的基本类型是在堆栈上创建的，而所有的对象类型都是在堆上创建的<br/>
（3）基本数据可以自动封装成封装类,基本数据类型的好处就是速度快（不涉及到对象的构造和回收），封装类的目的主要是更好的处理数据之间的转换，方法很多，用起来也方便。

* 简述九种基本数据类型的大小，以及他们的封装类

答：

| 基本类型 | 大小(字节) | 默认值 | 封装类 |
| ----- | :---- | :---- | :---- |
| byte | 1 | (byte)0 | Byte |
| short | 2 | (short)0 | Short |
| int | 4 | 0 | Integer |
| long | 8 | 0L | Long |
| float | 4 | 0.0f | Float |
| double | 8 | 0.0d | Double |
| boolean | - | false | Boolean |
| char | 2 | null(\u0000) | Character |
| void | - | - | Void |

* int 和 Integer 哪个会占用更多的内存？ int 和 Integer 有什么区别？parseInt()函数在什么时候使用到

答：Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。

区别：（1）Integer是int的包装类，int则是java的一种基本数据类型<br/>
（2）Integer变量必须实例化后才能使用，而int变量不需要<br/>
（3）Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值<br/>
（4）Integer的默认值是null，int的默认值是0<br/>

字符串转换为整数时使用。

* float和double的默认值是多少

答：0.0f，0.0d。

* 如何去小数四舍五入保留小数点后两位

答：DecimalFormat df = new DecimalFormat("#.00");<br/>
df.format(目标浮点数);或者String.format("%.2f", 目标浮点数);

* char 型变量中能不能存贮一个中文汉字，为什么

答：能，char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字。

### 类型转换
* 怎样将 bytes 转换为 long 类型

答：java.nio.ByteBuffer本身就有getLong,getInt,getFloat….方法,只要将byte[]转换为ByteBuffer就可以实现所有primitive类型的数据读取。

* 怎么将 byte 转换为 String

答：String 接收 byte[] 参数的构造器new String(byte[]);

* 如何将数值型字符转换为数字

答：使用对象包装类，如Integer.parseInt("1234")。

* 我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象

答：因为Java中byte是用8位来存储，只能表示-128~127之间的数，当由int强制类型转化为byte时，系统就采取了截取int后8位的做法。

* 能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗

答：不行，因为double的精度比long型的高，不强制转换的情况，没法赋值。

* 类型向下转换是什么

答：把父类对象转为子类对象。

### 数组
* 如何权衡是使用无序的数组还是有序的数组

答：有序数组最大的好处：在于查找的时间复杂度是O(log n)，而无序数组是O(n)。插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)。

* 怎么判断数组是 null 还是为空

答：.length，空数组长度为0，null时会报空指针。

* 怎么打印数组？ 怎样打印数组中的重复元素

答：遍历打印。

* Array 和 ArrayList有什么区别？什么时候应该使用Array而不是ArrayList

答：<br/>
区别：（1）Array数组可以包含基本类型和对象类型；ArrayList却只能包含对象类型。
（2）Array的空间大小是固定的，，空间不够时也不能再次申请；ArrayList的空间是动态增长的，如果空间不够，它会创建一个空间比原空间大一倍的新数组，然后将所有元素复制到新数组中，接着抛弃旧数组。
（3）ArrayList的方法比Array数组功能多。如：add(),remove()。

如果想要保存一些在整个程序运行期间都会存在而且不变的数据，就使用Array。   

* 数组和链表数据结构描述，各自的时间复杂度

答：数组必须事先定义固定的长度（元素个数），不能适应数据动态地增减的情况。链表动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。

按序号查找时，数组可以随机访问，时间复杂度为O(1)，而链表不支持随机访问，平均需要O(n)；　

按值查找时，若数组无序，数组和链表时间复杂度均为O(1)，但是当数组有序时，可以采用折半查找将时间复杂度降为O(logn)；　

数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。

* 数组有没有length()这个方法? String有没有length()这个方法

答：数组没有length()方法但是有length属性；String中有length()这个方法。用来得到字符串的长度。

### 队列
* 队列和栈是什么，列出它们的区别

答：队列先进先出，栈先进后出。栈（Stack）是限定只能在表的一端进行插入和删除操作的线性表。队列（Queue）是限定只能在表的一端进行插入和在另一端进行删除操作的线性表。

* BlockingQueue是什么

答：阻塞队列。当一个线程试图对一个已经满了的队列进行入队列操作时，它将会被阻塞，除非有另一个线程做了出队列操作；同样，当一个线程试图对一个空队列进行出队列操作时，它将会被阻塞，除非有另一个线程进行了入队列操作。

* 简述 ConcurrentLinkedQueue LinkedBlockingQueue 的用处和不同之处。

答：ConcurrentLinkedQueue是并发队列也就是非阻塞队列，按FIFO原则进行排序，采用CAS算法来保证一致性；<br/>
	LinkedBlockingQueue是阻塞队列，实现是线程安全的，采用锁，实现了先进先出等特性，是作为生产者消费者的首选，实现了BlockingQueue接口，增加了take和put方法，这两个方法正是队列操作的阻塞版本，可以指定容量，也可以不指定，不指定的话，默认最大是Integer.MAX_VALUE。

不同：（1）ConcurrentLinkedQueue是非阻塞队列；LinkedBlockingQueue是阻塞队列。
（2）LinkedBlockingQueue 多用于任务队列；而ConcurrentLinkedQueue  多用于消息队列。
（3）ConcurrentLinkedQueue采用CAS算法来保证线程安全；LinkedBlockingQueue采用加锁来保证线程安全。

### ArrayList、Vector、LinkedList的存储性能和特性

答：<br/>
1.ArrayList 采用的是数组形式来保存对象的，这种方式将对象放在连续的位置中，所以最大的缺点就是插入删除时非常麻烦.

2.LinkedList 采用的将对象存放在独立的空间中，而且在每个空间中还保存下一个链接的索引 但是缺点就是查找非常麻烦 要丛第一个索引开始

3.ArrayList和Vector都是用数组方式存储数据,此数组元素数要大于实际的存储空间以便进行元素增加和插入操作,他们都允许直接用序号索引元素,但是插入数据元素涉及到元素移动等内存操作,所以索引数据快而插入数据慢.

4.Vector使用了sychronized方法(线程安全),所以在性能上比ArrayList要差些.

5.LinkedList使用双向链表方式存储数据,按序号索引数据需要前向或后向遍历数据，所以索引数据慢,是插入数据时只需要记录前后项即可,所以插入的速度快.

6.arraylist和vector的区别?

1).同步性:Vector是线程安全的，也就是说是同步的，而ArrayList是线程不安全的，不是同步的。

2).数据增长:当需要增长时,Vector默认增长为原来一培，而ArrayList却是原来的一半。

3).Vector不能有重复的值，ArrayList则可有重复的值。

### ByteBuffer 与 StringBuffer有什么区别

答：ByteBuffer 中存放的是字节，StringBuffer存放的是字符串。

### 描述下String,StringBuilder以及 StringBuffer区别

答：（1）String：字符串常量，StringBuffer：字符串变量，StringBuilder：字符串变量
（2）执行速度：StringBuilder>StringBuffer>String
（3）StringBuffer 是线程安全的；StringBuilder 是非线程安全的；

注：String在声明时不能指定长度只能在实例化时指定。

### HashMap
* HashMap的工作原理是什么

答：HashMap是基于散列法（又称哈希法hashing）的原理，使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket（桶）位置来储存Entry对象。

* 内部的数据结构是什么

答：HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。数组中有很多Entry，Entry就是数组中的元素，每个 Map.Entry 其实就是一个key-value对，它持有一个指向下一个元素的引用，这就构成了链表。

* HashMap 的 table的容量如何确定？loadFactor 是什么？ 该容量如何变化？这种变化会带来什么问题？

答：table 数组大小是由 capacity 这个参数确定的，默认是16，也可以构造时传入，最大限制是1<<30;loadFactor 是装载因子，主要目的是用来确认table 数组是否需要动态扩展，默认值是0.75，比如table 数组大小为 16，装载因子为 0.75 时，threshold 就是12，当 table 的实际大小超过 12 时，table就需要动态扩容； 扩容时，调用 resize() 方法，将 table 长度变为原来的两倍；如果数据很大的情况下，扩展时将会带来性能的损失，在性能要求很高的地方，这种损失很可能很致命。

* HashMap 实现的数据结构是什么？如何实现

答：HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。HashMap底层就是一个数组结构，数组中的每一项又是一个链表。

* HashMap 和 HashTable、ConcurrentHashMap 的区别

答：<br/>
（1）HashMap是非线程安全的，HashTable是线程安全的。

（2）HashMap的键和值都允许有null存在，而HashTable则都不行。

（3）因为线程安全、哈希效率的问题，HashMap效率比HashTable的要高。

（4）ConcurrentHashMap是线程安全的HashMap的实现，对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的syn关键字锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。ConCurrentHashMap键值都不允许为null。

* HashMap的遍历方式及效率

答：<br/>
方式1：通过遍历keySet()遍历HashMap的value，根据key获取映射的vlaue，需要调用get()方法十万次,效率不高。

方式2：通过遍历values()遍历HashMap的value，获取集合中的values，遍历value。

方式3：通过entrySet().iterator()遍历HashMap的key和映射的value，获取Entry<K,V>类型的Set集合，遍历这个集合，获取每一个Entry<K,V>。

* HashMap、LinkedMap、TreeMap的区别

答：HashMap根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。

LinkedHashMap也是一个HashMap,但是内部维持了一个双向链表,可以保持保存了记录的插入顺序。也可以在构造时带参数，按照应用次数排序。

TreeMap实现SortMap接口，能够把它保存的记录根据键排序。默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。

* 如何决定选用HashMap还是TreeMap

答：按顺序读取值时使用TreeMap，仅需要读取而不需按序用HashMap。

* 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办

答：负载因子默认是0.75，HashMap超过了负载因子定义的容量，也就是说超过了（HashMap的大小*负载因子）这个值，那么HashMap将会创建为原来HashMap大小两倍的数组大小，作为自己新的容量，这个过程叫resize或者rehash。

* HashMap 是线程安全的吗？并发下使用的 Map 是什么，它们内部原理分别是什么，比如存储方式、 hashcode、扩容、 默认容量等

答：不是。Hashtable、ConcurrentHashMap和synchronized Map。
HashTable源码中是使用synchronized来保证线程安全的，当一个线程使用put方法时，另一个线程不可以使用任何方法。ConcurrentHashMap引入了分割，将Map分割成了不同的部分，在执行更新操作时只锁住一部分。根据默认的并发级别(concurrency level)，Map被分割成16个部分，并且由不同的锁控制。SynchronizedMap类中使用了synchronized同步关键字来保证对Map的操作是线程安全的。

### HashSet
* HashSet和TreeSet有什么区别

答：
1. 底层存储的数据结构不同。HashSet底层用的是HashMap哈希表结构存储，而TreeSet底层用的是TreeMap树结构存储。

2.存储时保证数据唯一性依据不同。HashSet是通过复写hashCode()方法和equals()方法来保证的，而TreeSet通过Compareable接口的compareTo()方法来保证的。

3.有序性不一样。HashSet无序，TreeSet有序。

* HashSet 内部是如何工作的

答：当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据 hashCode值来决定该对象在HashSet中存储位置。简单的说，HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值相等。注意，如果要把一个对象放入HashSet中，重写该对象对应类的equals方法，也应该重写其hashCode()方法。其规则是如果两个对 象通过equals方法比较返回true时，其hashCode也应该相同。

* WeakHashMap 是怎么工作的？

答：储结构类似于HashMap,使用弱引用作为内部数据的存储方案。它的键是“弱键”，里面存放了键对象的弱引用，当某个键不再正常使用时，会从WeakHashMap中被自动移除。当一个键对象被垃圾回收，那么相应的值对象的引用会从Map中删除。

### Set
* Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢？是用 == 还是 equals()？ 它们有何区别?

答： Set是Collection容器的一个子接口，它不允许出现重复元素，当然也只允许有一个null对象。应该用equals()，因为==是判断二者是否为同一对象，equals()是判断是否引用同一个对象。而Set中存放的是对对象的引用，所以用equals更好。

* TreeMap：TreeMap 是采用什么树实现的？TreeMap、HashMap、LindedHashMap的区别。TreeMap和TreeSet在排序时如何比较元素？

答：红黑树。Hashmap 是一个最常用的Map,它根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。

LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。

TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。

* Collections工具类中的sort()方法如何比较元素？

答：TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。

* TreeSet：一个已经构建好的 TreeSet，怎么完成倒排序。

答：1、自然顺序
即类要实现Comparable接口，并重写compareTo()方法，TreeSet对象调用add()方法时，会将存入的对象提升为Comparable类型，然后调用对象中的compareTo()方法进行比较，根据比较的返回值进行存储。
因为TreeSet底层是二叉树，当compareTo方法返回0时，不存储；当compareTo方法返回正数时，存入二叉树的右子树；当compareTo方法返回负数时，存入二叉树的左子树。如果一个类没有实现Comparable接口就将该类对象存入TreeSet集合，会发生类型转换异常。

2、比较器顺序Comparator
创建TreeSet对象的时候可以指定一个比较器，即传入一个Comparator对象，那么TreeSet会优先按照Comparator中的compare()方法排序，compare方法中有两个参数，第一个是调用该方法的对象，第二个值集合中已经存入的对象。


* EnumSet 是什么

答：EnumSet 是一个与枚举类型一起使用的专用 Set 实现。枚举set中所有元素都必须是同类型，枚举类型在创建 set 时显式或隐式地指定。枚举 set 在内部表示为位向量。此类的空间和时间性能很好。

### Hash算法
* Hashcode 的作用

答：1、HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的

2、如果两个对象equals相等，那么这两个对象的HashCode一定也相同

3、如果对象的equals方法被重写，那么对象的HashCode方法也尽量重写

4、如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置

* 简述一致性 Hash 算法

答：一致性哈希将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1。基本思想就是将对象和 cache 都映射到同一个 hash 数值空间中，并且使用相同的 hash算法。首先求出memcached服务器（节点）的哈希值，并将其配置到0～232的圆（continuum）上。然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过232仍然找不到服务器，就会保存到第一台memcached服务器上。

* 有没有可能 两个不相等的对象有相同的 hashcode？当两个对象 hashcode 相同怎么办？如何获取值对象

答：有可能。使用equals()方法来判断两个对象是否相同。不同则以链表的形式存储。

* 为什么在重写 equals 方法的时候需要重写 hashCode 方法？equals与 hashCode 的异同点在哪里

答：1、如果两个对象相同（即用equals比较返回true），那么它们的hashCode值一定要相同；

2、如果两个对象的hashCode相同，它们并不一定相同（即用equals比较返回false）  
如果不重写可能会出现，对象相同而hashcode却不相同的情况。

* a.hashCode() 有什么用？与 a.equals(b) 有什么关系

答：hashCode() 方法是相应对象整型的 hash 值。判断两个对象是否相等就是先判断他们的hashcode是否相等，若想等再视同equals方法判断，equals方法返回true，hashcode一定相同。

* hashCode() 和 equals() 方法的重要性体现在什么地方

答：散列存储集合如HashMap的很多函数要基于equal()函数和hashCode()函数。hashCode()用来定位要存放的位置，equal()用来判断是否相等。hashCode()用来定位要存放的位置，equal()用来判断是否相等。 

* Object：Object有哪些公用方法？Object类hashcode,equals 设计原则？ sun为什么这么设计？Object类的概述

答：clone，实现对象的浅复制；equals，判断对象是否是同一个；hashcode，用于哈希查找；getClass，获得运行时类型；wait，使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断；notify，唤醒在该对象上等待的某个线程；notifyAll，唤醒在该对象上等待的所有线程；toString，转换成字符串。

设计原则：（1）在程序执行期间，只要equals方法的比较操作用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法必须始终如一地返回同一个整数。
（2）如果两个对象根据equals方法比较是相等的，那么调用两个对象的hashCode方法必须返回相同的整数结果。
（3）如果两个对象根据equals方法比较是不等的，则hashCode方法不一定得返回不同的整数。

* 如何在父类中为子类自动完成所有的 hashcode 和 equals 实现？这么做有何优劣。

答：

* 可以在 hashcode() 中使用随机数字吗？

答：不可以，两个相同的对象可能会出现hashcode不同的情况。

### LinkedHashMap
* LinkedHashMap 和 PriorityQueue 的区别是什么

答：PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，但是 LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 可保证遍历顺序是元素插入的顺序。

### List
#### List, Set, Map三个接口，存取元素时各有什么特点

答：List与Set都是单列元素的集合，它们有一个功共同的父接口Collection。

List表示有先后顺序的集合。存元素：多次调用add(Object)方法，也可以插队，即调用add(int index,Object)方法，就可以指定当前对象在集合中的存放位置。取元素：Iterator接口取得所有，逐一遍历各个元素；调用get(index i)来明确说明取第几个。

Set里面不允许有重复的元素，内部排序。存元素：add（）方法，当集合中没有某个元素，此时add方法可成功加入该元素时，则返回true；当集合含有与某个元素equals相等的元素时，此时add方法无法加入该元素，返回结果为false。取元素：只能以Iterator接口取得所有的元素，再逐一遍历各个元素。

Map是双列的集合。存元素：put（key,value）方法，key不可重复。取元素：可以根据key获取value，也可以获得所有的key的集合，还可以获得所有的value的集合，还可以获取Map.Entry对象的集合。

#### List, Set, Map 是否继承自 Collection 接口

答：List，Set是，Map不是。

#### 遍历一个 List 有哪些不同的方式

答：iterator；for（Obj：list）；for（i;i<list.size；i++）

#### LinkedList
* LinkedList 是单向链表还是双向链表

答：双向链表。

* LinkedList 与 ArrayList 有什么区别

答：LinkedList是基于链表的，ArrayList是基于数组的。

访问某个元素时，LinkedList不如ArrayList，因为要移动指针去寻找该元素。

对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据

* 描述下 Java 中集合（Collections），接口（Interfaces），实现（Implementations）的概念。

答：集合：一个将多种元素放在单个单元中的简单对象。集合被用于保存、获取、操作和聚合数据通信。

接口：一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。

实现：一个类实现一个接口用的关键字，用来实现接口中定义的抽象方法。

* 插入数据时，ArrayList, LinkedList, Vector谁速度较快？

答：ArrayList和Vector都是使用数组方式存储数据，插入元素要涉及数组元素移动等内存操作，所以速度较慢。Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差。LinkedList使用双向链表实现存储，插入数据时只需要记录本项的前后项即可，所以插入速度较快。

#### ArrayList
* ArrayList 和 HashMap 的默认大小是多数

答：ArrayList、Vector默认初始容量为10，HashMap：默认初始容量为16。

* ArrayList 和 LinkedList 的区别，什么时候用 ArrayList？

答：LinkedList是基于链表的，ArrayList是基于数组的。

访问某个元素时，LinkedList不如ArrayList，因为要移动指针去寻找该元素。

对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。

当要频繁访问元素时，使用ArrayList。

* ArrayList 和 Set 的区别？

答：ArrayList可以元素重复，set元素不可重复。

ArrayList允许多个null；Set最多有一个null元素。

Arraylist是有序链表，而set是无序的。

* ArrayList, LinkedList, Vector的区别

答：（1）ArrayList、LinkedList：非线程安全；Vector线程安全。
（2）LinkedList基于双向链表实现；ArrayList，Vector基于数组实现。
（3）ArrayList和Vector当数组长度不够时，其内部会创建一个更大的数组，然后将原数组中的数据拷贝至新数组中，如需扩展，则每次至少扩展至(原长度*3)/2 + 1；Vector每次至少扩展至原长度的2倍。
（4）ArrayList查询和修改效率高于LinkedList；ArrayList插入和删除效率低于LinkedList。

* ArrayList是如何实现的，ArrayList 和 LinkedList 的区别

答：
①数据存储是基于数组实现的，默认初始容量为10；

②添加数据时，首先需要检查元素个数是否超过数组容量，如果超过了则需要对数组进行扩容；插入数据时，需要将插入点k开始到数组末尾的数据全部向后移动一位。

③数组的扩容是新建一个大容量（原始数组大小+扩充容量）的数组，然后将原始数组数据拷贝到新数组，然后将新数组作为扩容之后的数组。数组扩容的操作代价很高，我们应该尽量减少这种操作。

④删除数据时，需要将删除点+1位置开始到数组末尾的数据全部向前移动一位。

⑤获取数据很快，根据数组下表可以直接获取。

* ArrayList如何实现扩容

答：数组的扩容是新建一个大容量（原始数组大小+扩充容量，至少为原容量的1.5倍+1）的数组，然后将原始数组数据拷贝到新数组，然后将新数组作为扩容之后的数组。

* Array 和 ArrayList 有何区别？什么时候更适合用Array

答：（1）array能够存放基本类型和对象类型；arrayList只能存储对象类型。
（2）array空间是固定的，即使不够也不能重新申请；arrayList是动态增长的，空间不够时，会创建一个新的数组，把原有的元素复制到新的数组中，释放旧的数组。


* 说出ArraList,Vector, LinkedList的存储性能和特性

答：ArrayList和Vector都是使用数组方式存储数据，插入元素要涉及数组元素移动等内存操作，所以速度较慢。Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差。LinkedList使用双向链表实现存储，插入数据时只需要记录本项的前后项即可，所以插入速度较快。

### Map
* Map, Set, List, Queue, Stack

答：

* Map 接口提供了哪些不同的集合视图

答：（1）Set keyset()：返回map中包含的所有key的一个Set视图。
（2）Collection values()：返回一个map中包含的所有value的一个Collection视图。
（3）Set<Map.Entry<K,V>> entrySet()：返回一个map钟包含的所有映射的一个集合视图。

* 为什么 Map 接口不继承 Collection 接口

答：Map不是集合，与集合处于同一等级。Map是key,value形式的数据结构，且key不能重复。

### Collections
* 介绍Java中的Collection FrameWork。集合类框架的基本接口有哪些

答：成员主要包括两种类型，即：Collection和Map类型。 在Java中提供了Collection和Map接口。其中List和Set继承了Collection接口；同时用Vector、ArrayList、LinkedList三个类实现List接口，HashSet、TreeSet实现Set接口。直接有HashTable、HashMap、TreeMap实现Map接口。

基本接口：Collection、List、Map、Set、HashSet、HashMap、ArrayList、LinkedList、TreeMap、TreeSet。

* Collections类是什么？Collection 和 Collections的区别？Collection、Map的实现

答：Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。

Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。

* 集合类框架的最佳实践有哪些

答：根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的大小是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。<br/>
有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。<br/>
为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。<br/>
使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。<br/>
编程的时候接口优于实现。<br/>
底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。<br/>

* 为什么 Collection 不从 Cloneable 和 Serializable 接口继承

答：克隆（cloning）或者序列化（serialization）的语义和含义是跟具体的实现相关的。因此应该由集合类的具体实现类来决定如何被克隆或者序列化.

* 说出几点 Java 中使用 Collections 的最佳实践？
Collections 中 遗留类 (HashTable、Vector) 和 现有类的区别

答：

### 什么是 B+树，B-树，列出实际的使用场景。

答：<br/>
B+树：
⑴有n 棵子树的结点中含有n 个关键码；<br/>
⑵所有的叶子结点中包含了全部关键码的信息，及指向含有这些关键码记录的指针，且叶子结点本身依关键码的大小自小而大的顺序链接；<br/>
⑶所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键码<br/>

B-树：一种平衡的多路查找树
⑴树中每个结点至多有m 棵子树；<br/>
⑵若根结点不是叶子结点，则至少有两棵子树；<br/>
⑶除根结点之外的所有非终端结点至少有[m/2] 棵子树；<br/>
⑷所有的非终端结点中包含以下信息数据：关键码从小到大，[阶数/2]-1<=关键码的个数<=阶数-1,左子树关键码全小于根节点，右子树关键码大于根节点。<br/>
⑸所有的叶子结点都出现在同一层次上，并且不带信息<br/>
实际的使用场景：用在磁盘文件组织 数据索引和数据库索引。

## 接口

### Comparator 与 Comparable 接口是干什么的？列出它们的区别
答：
Comparable接口被用来提供对象的自然排序，我们可以使用它来提供基于单个逻辑的排序。在集合内部定义的方法实现的排序。

Comparator接口被用来提供不同的排序算法，我们可以选择需要使用的Comparator来对给定的对象集合进行排序。在集合外部定义的方法实现的排序。

## JVM

### 参数
* 说说你知道的几种主要的jvm 参数

答：-Xms：初始堆大小<br/>
-Xmx：堆最大内存<br/>
-Xmn：设置新生代区大小<br/>
-Xss：设置每个java线程的堆栈大小<br/>
-XX:+/-UseTLAB：设置是否使用本地线程分配缓冲
-XX:+PrintFlagsFinal：显示所有可设置的参数及”参数处理”后的默认值<br/>
-XX:NewSize :设置年轻代的大小<br/>
-XX:NewRatio :设置年轻代和老年代的比值<br/>
-XX:PermSize and MaxPermSize :设置持久带的大小<br/>
-XX:SurvivorRatio=n :设置年轻代中E区与俩个S区的比值<br/>
-verbose:gc :记录GC运行以及运行时间<br/>
-XX:+PrintGCDetails :记录GC运行时的详细数据信息，包括新生占用的内存大小及消耗时间
-XX:-PrintGCTimeStamps :打印收集的时间戳
-XX:+UseParallelGC :使用并行垃圾收集器
-XX:GCLogFileSize=1M：控制GC日志文件的大小
-XX:-UseCompressedOops：关闭CompressedOops
-XX:PretenureSizeThreadshold 设置大对象的阈值
-XX:MaxTenuringThreshold 设置长期存活对象转老年代的阈值

* -XX:+UseCompressedOops 有什么作用

答：oop普通对象指针（ordinary object pointer）。Compressed oops（压缩了的普通对象指针）。该参数是设置跑在64位平台下的JVM中使用32位的oop，用来压缩对象在jvm堆栈内存中的大小。启用CompressOops后，会压缩的对象：
• 每个Class的属性指针（静态成员变量）
• 每个对象的属性指针
• 普通对象数组的每个元素指针

一些特殊类型的指针，JVM是不会优化的。比如本地变量，堆栈元素，入参，返回值，NULL指针，PermGen的Class对象指针。

### 类加载器(ClassLoader)
* Java 类加载器都有哪些

答：<br/>
（1）启动（Bootstrap）类加载器。主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是虚拟机自身的一部分，它负责将 <JAVA_HOME>/lib路径下的核心类库或-Xbootclasspath参数指定的路径下的jar包加载到内存中，注意必由于虚拟机是按照文件名识别加载jar包的，如rt.jar，如果文件名不被虚拟机识别，即使把jar包丢到lib目录下也是没有作用的。

（2）扩展（Extension）类加载器。扩展类加载器是指Sun公司实现的sun.misc.Launcher$ExtClassLoader类，由Java语言实现的，是Launcher的静态内部类，它负责加载<JAVA_HOME>/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用标准扩展类加载器。

（3）系统（System）类加载器。它负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器。 

* JVM如何加载字节码文件

答：虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验，转换分析和初始化，最终形成可以被虚拟节直接使用的JAVA类型，这就是虚拟机的类加载机制。生命周期：加载->验证->准备->解析->初始化->使用->卸载。

### 内存管理
* JVM内存分哪几个区，每个区的作用是什么

答：<br/>
（1）程序计数器：可以看作是当前线程所执行的字节码的行号指示器。在使用多线程时，为了线程切换后能恢复到正确的执行位置，每条线程都需要有个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为"线程私有"的内存。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。

（2）java虚拟机栈：生命周期与线程相同。每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。局部变量表存放了编译期可知的各种基本数据类型、对象引用、returnAddress类型。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

（3）本地方法栈：本地方法栈与虚拟机栈非常相似，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。

（4）java堆：Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，通过-Xmx 和-Xms控制。

（5）方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。不需要连续的内存和可以选择固定大小，可以选择不实现垃圾收集。

heap区又分为： 
- Eden Space（伊甸园）、 
- Survivor Space(幸存者区)、 
- Old Gen（老年代）。

非heap区又分： 
- Code Cache(代码缓存区)； 
- Perm Gen（永久代）； 
- Jvm Stack(java虚拟机栈)； 
- Local Method Statck(本地方法栈)；



* 一个对象从创建到销毁都是怎么在这些部分里存活和转移的

答：

* 解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法

答：（1）定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用JVM中的栈空间；
（2）通过new关键字和构造器创建的对象则放在堆空间；
3）方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据；程序中的字面量

* JVM中哪个参数是用来控制线程的栈堆栈小

答：-Xms：初始堆大小<br/>
-Xmx：堆最大内存<br/>

* 简述内存分配与回收策略

答：<br/>
（1）对象优先在Eden区分配，对象通常在新生代的Eden区进行分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次新生代GC。<br/>
（2）大对象直接进入老年代，需要大量连续内存空间的Java对象称为大对象，大对象的出现会导致提前触发垃圾收集以获取更大的连续的空间来进行大对象的分配。虚拟机提供了-XX:PretenureSizeThreadshold参数来设置大对象的阈值，超过阈值的对象直接分配到老年代。<br/>
（3）长期存活的对象进入老年代，每个对象有一个对象年龄计数器，与前面的对象的存储布局中的GC分代年龄对应。对象出生在Eden区、经过一次Minor GC后仍然存活，并能够被Survivor容纳，设置年龄为1，对象在Survivor区每次经过一次Minor GC，年龄就加1，当年龄达到一定程度（默认15），就晋升到老年代，虚拟机提供了-XX:MaxTenuringThreshold来进行设置。<br/>
（4）动态对象年龄判断，对象的年龄到达了MaxTenuringThreshold可以进入老年代，同时，如果在survivor区中相同年龄所有对象大小的总和大于survivor区的一半，年龄大于等于该年龄的对象就可以直接进入老年代。无需等到MaxTenuringThreshold中要求的年龄。<br/>
（5）空间分配担保，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行新生代 GC，否则将进行老年代 GC。

* 简述重排序，内存屏障，happen-before，主内存，工作内存

答：<br/>
重排序：编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段，前提是这些指令没有依赖关系。

内存屏障：是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。

happen-before：在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。1）如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 2）两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。

主内存：包括本地方法区和堆。所有的变量都存储在主内存中(虚拟机内存的一部分)，对于所有线程都是共享的。线程之间无法直接访问对方的工作内存中的变量，线程间变量的传递均需要通过主内存来完成。

工作内存：包括线程私有的栈和程序计数器。每条线程都有自己的工作内存，工作内存中保存的是主存中某些变量的拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。

* Java中存在内存泄漏问题吗？请举例说明

答：存在。一个不再被程序使用的对象或变量一直被占据在内存中。

例：<br/>
（1）静态集合类，例如HashMap和Vector。
（2）各种连接，例如数据库的连接、网络连接以及IO连接等。
（3）变量不合理的作用域。如果一个变量定义的作用域大于其使用范围，很有可能会造成内存泄漏。
（4）单例对象在被初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露。
（5）当一个对象被存储进HashSet集合中以后，如果修改这个对象中那些参与计算哈希值得字段，会导致再也无法获取该对象，也无法将其从HashSet集合中删除，造成内存泄漏。

* 简述 Java 中软引用（SoftReference）、弱引用（WeakReference）和虚引用

答：<br/>
软引用：用来描述一些有用但并不是必需的对象，如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。可用来实现内存敏感的高速缓存。

弱引用：在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。

虚引用：虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列联合使用。

软引用适合用来进行缓存，当内存不够时能让JVM回收内存。弱引用能用来在回调函数中防止内存泄露。虚引用主要用于检测对象是否已经从内存中删除。

* 内存映射缓存区是什么

答：传统的IO模型是先从磁盘将文件内容读取到OS内核的IO缓存区，再把数据从缓冲区拷贝到进程的私有地址空间。这样是为了减少磁盘IO的操作，提高性能。而NIO中是将进程的私有地址空间中的一部分区域虚拟地址与文件对象建立映射关系，就像从内存中读写文件一样。当进程引用这部分虚拟地址时，会触发缺页异常，此时OS会根据映射关系直接将文件的这部分数据拷贝到用户私有空间去，效率更高。

### jstack，jstat，jmap，jconsole怎么用

答：
jstack：观察jvm中当前所有线程的运行情况和线程当前状态。如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。

jstat：jstat利用JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对进程的classloader，compiler，gc情况；
可以用来监视VM内存内的各种堆和非堆的大小及其内存使用量，以及加载类的数量。

jmap：监视进程运行中的jvm物理内存的占用情况，该进程内存内，所有对象的情况，例如产生了哪些对象，对象数量；系统崩溃时，jmap 可以从core文件或进程中获得内存的具体匹配情况，包括Heap size, Perm size等等。jmap -histo pid>a.log将该进程中所有的对象情况输出到a.log中。

jconsole：一个java GUI监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器VM。命令行里打 jconsole，选则进程就可以了。

### 32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？32 位和 64 位的 JVM，int 类型变量的长度是多数？

答：理论上32 位 JVM最大堆内存为4GB，64 位 JVM 最大堆内存为4GB。32 位JVM中int类型变量长度为8byte，64位JVM中int类型变量长度为16byte。

### 怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位

答：System.getProperty("sun.arch.data.model")

### JVM自身会维护缓存吗？是不是在堆中进行对象分配，操作系统的堆还是JVM自己管理堆

答：会。在JVM自己的堆中创建对象。

### 什么情况下会发生栈内存溢出

答：递归调用、大量循环或死循环、全局变量过多、数组、List、map数据过大。

### 双亲委派模型是什么

答：要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，而这种父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）。

内容：某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。

## GC

### 概念

* GC是什么？为什么要有GC

答：GC是垃圾收集的意思。内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。

* 什么时候会导致垃圾回收

答：对象的回收：1）对象没有引用 2）作用域发生未捕获异常 3）程序在作用域正常执行完毕 4）程序执行了System.exit() 5）程序发生意外终止

方法区的回收：1）所有实例被回收 2）加载该类的ClassLoader被回收 3）Class对象无法通过任何途径访问(包括反射)

* GC是怎么样运行的

答：对象被创建时，GC就开始监控这个对象的地址、大小以及使用情况。GC采用有向图的方式记录和管理堆(heap)中的所有对 象，通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。GC在JVM中通常由一个或一组进程来实现，优先级很低，它本身也和用户程序一样占用heap空间，运行时也占用CPU，当GC进程运行时，应用程序停止运行。

* 新老以及永久区是什么

答：新生代分为Eden和Survivor，新建的对象都是用新生代分配内存，Eden空间不足的时候，会把存活的对象转移到Survivor中，新生代大小可以由-Xmn来控制。

旧生代：用于存放新生代中经过多次垃圾回收仍然存活的对象。

永久代：存放hotspot的方法区。用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

* GC 有几种方式？怎么配置

答：<br/>
串行GC（SerialGC）：在整个扫描和复制过程采用单线程的方式来进行，适用于单CPU、新生代空间较小及对暂停时间要求不是非常高的应用上，是client级别默认的GC方式，可以通过-XX:+UseSerialGC来强制指定。

并行回收GC（ParallelScavenge）：在整个扫描和复制过程采用多线程的方式来进行，适用于多CPU、对暂停时间要求较短的应用上，是server级别默认采用的GC方式，可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数。

并行GC（ParNew）：与旧生代的并发GC配合使用

* 什么时候一个对象会被GC？ 如何判断一个对象是否存活

答：1）对象没有引用 2）作用域发生未捕获异常 3）程序在作用域正常执行完毕 4）程序执行了System.exit() 5）程序发生意外终止

给对象添加一个引用计数器，每当有一个地方引用它时，计数器的值就+1；当引用失效时，值就-1；任何时刻计数器为0的对象就是不能再被使用的。

通过一系列的成为”GC Roots”的对象作为起始点，从这些结点开始向下搜索，搜索所经过的路径成为“引用链”,当一个对象到GC Roots没有任何引用链时，则证明此对象是不可用的。

* System.gc() Runtime.gc()会做什么事情？ 能保证 GC 执行吗

答：触发垃圾回收。不能，只是建议GC进行垃圾回收，垃圾收集器进不进行收集是不确定的。

* 垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？

答：可以。System.gc() Runtime.gc()

* Minor GC 、Major GC、Young GC 与 Full GC分别在什么时候发生

答：Minor GC：当 JVM 无法为一个新的对象分配空间时会触发 Minor GC，如： Eden 区满了。

Major GC：当老年代剩余内存无法装载新生代存活的对象的时候和无法装载大对象的时候。

Full GC：(1)年老代内存不足；(2)持久代内存不足；(3)统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间；(4) CMS GC时出现promotion failed和concurrent mode failure；(5)调用System.gc的时候

* 垃圾回收算法的实现原理

答：
引用计数法：每个对象有一个专门的空间维护一个引用计数器，当该对象被引用时，计数器加一，引用消失时则计数器减一，当该对象引用数为0时则回收该对象。

标记-清除：从根节点开始，对所有可达对象做一次标记。每次GC，会先扫描内存区标记存活对象，而后释放未被标记的对象空间。

标记-压缩：从根节点开始，对所有可达对象做一次标记。每次GC，并不清理未标记的对象，而是将所有存活对象压缩到内存一端。之后清理边界外所有的空间。

复制算法：将原有的内存空间分为两块，每次只使用其中一块，在GC时，将正在使用的对象复制到未使用的内存中，清除使用的内存中所有对象，交换两个内存中的角色。

分代思想：将对象按存活周期分类，短命对象归为新生代，长命对象归为老年代。存活对象很少时用复制算法，很多时用标记清除或标记压缩算法。

* 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？

答：不会，在下一个GC周期中回收。

* 垃圾回收的最佳做法是什么

答：

### GC收集器有哪些
* 垃圾回收器的基本原理是什么？

答：当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。

* 串行(serial)收集器和吞吐量(throughput)收集器的区别是什么

答：吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器整个扫描和复制过程均采用单线程的方式，必须暂停其他所有的工作线程直到它收集结束。对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。

* Serial 与 Parallel GC之间的不同之处

答：<br/>
Serial：一个单线程的收集器，在进行垃圾收集时候，必须暂停其他所有的工作线程直到它收集结束。特点：CPU利用率最高，停顿时间即用户等待时间比较长。适用场景：小型应用-XX:+UseSerialGC

Parallel：采用多线程来通过扫描并压缩堆。停顿时间短，回收效率高，对吞吐量要求高。适用场景：大型应用，科学计算，大规模数据采集等。XX:+USeParNewGC 

* CMS 收集器 与 G1 收集器的特点与区别

答：<br/>
CMS收集器：采用“标记-清除”算法实现，使用多线程的算法去扫描堆，对发现未使用的对象进行回收。特点：响应时间优先，减少垃圾收集停顿时间。适应场景：服务器、电信领域等。-XX:+UseConcMarkSweepGC

G1收集器：在G1中，堆被划分成 许多个连续的区域(region)。采用“标记-整理”算法和“复制”算法。特点：支持很大的堆，高吞吐量。支持多CPU和垃圾回收线程。在主线程暂停的情况下，使用并行收集。在主线程运行的情况下，使用并发收集。–XX:+UseG1GC

* CMS垃圾回收器的工作过程

答：初始标记阶段，进行可达性分析，标记GC ROOT能直接关联到的对象。

并发标记阶段，进行GC ROOT TRACING，在第一个阶段被暂停的线程重新开始运行。由前阶段标记过的对象出发，所有可到达的对象都在本阶段中标记。

并发预处理阶段，标记从新生代晋升的对象、新分配到老年代的对象以及在并发阶段被修改了的对象。

重标记阶段，暂停所有用户线程，重新扫描堆中的对象，进行可达性分析,标记活着的对象。

并发清理。用户线程被重新激活，同时清理那些无效的对象。

重置。 CMS清除内部状态，为下次回收做准备。

* JVM 中一次完整的 GC 流程是怎样的？ 对象如何晋升到老年代

答：对象优先在新生代区中分配，若没有足够空间，Minor GC； 
大对象（需要大量连续内存空间）直接进入老年态；长期存活的对象进入老年态。如果对象在新生代出生并经过第一次MGC后仍然存活，年龄+1，若年龄超过一定限制（15），则被晋升到老年态。

* 吞吐量优先和响应优先的垃圾收集器选择

答：吞吐量优先的并行收集器：以到达一定的吞吐量为目标，适用于科学技术和后台处理等。 
响应时间优先的并发收集器：保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。

### GC策略
* 举个实际的场景，选择一个GC策略

答：

* JVM的永久代中会发生垃圾回收吗

答：会，当永久代满了或者超过阈值就会触发full GC。

### 收集方法
* 标记清除、标记整理、复制算法的原理与特点？分别用在什么地方

答：标记清除：从根节点开始，对所有可达对象做一次标记。每次GC，会先扫描内存区标记存活对象，而后释放未被标记的对象空间。特点：产生大量的内存碎片，下次若要存储一个大的对象，无法找到连续内存而又必须提前GC。

标记整理：从根节点开始，对所有可达对象做一次标记。每次GC，并不清理未标记的对象，而是将所有存活对象压缩到内存一端。之后清理边界外所有的空间。特点：不用考虑内存碎片的问题，但是内存减半，代价略高。

复制算法：将原有的内存空间分为两块，每次只使用其中一块，在GC时，将正在使用的对象复制到未使用的内存中，清除使用的内存中所有对象，交换两个内存中的角色。特点：

* 如果让你优化收集方法，有什么思路

答：

## 多线程

### 基本概念

* 什么是线程

答：线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。

* 多线程的优点

答：资源利用率更好，程序设计在某些情况下更简单，程序响应更快。

* 多线程的几种实现方式，用 Runnable 还是 Thread？

答：<br/>
Runnable：是个接口，可以避免继承的局限，还可以继承其他类，更容易实现资源共享。

Thread：是个类，实现了Runable接口。编写简单，直接使用this。但是不能继承其他类。

用哪个应该取决于继承上的需要。

* 什么是线程安全

答：在并发的情况之下，代码经过多线程使用，线程的调度顺序不影响任何结果。

* Vector, SimpleDateFormat 是线程安全类吗

答：Vector线程安全。SimpleDateFormat非线程安全。

* 什么 Java 原型不是线程安全的

答：不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。

* 哪些集合类是线程安全的

答：CorrentHashMap、HashTable、Vector、Stack。

* 多线程中的忙循环是什么
 
答：忙循环就是用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间。

* 如何创建一个线程

答：
（1）继承Thread类创建线程类 创建Thread子类的实例，即创建了线程对象。调用线程对象的start()方法来启动该线程。

（2）通过Runnable接口创建线程类 定义runnable接口的实现类，并重写该接口的run()方法，创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象。调用线程对象的start()方法来启动该线程。

（3）通过Callable和Future创建线程 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。创建Callable实现类的实例，使用FutureTask类来包装Callable对象。使用FutureTask对象作为Thread对象的target创建并启动新线程。get()方法来获得子线程执行结束后的返回值。

* 编写多线程程序有几种实现方式

答：同上。

* 什么是线程局部变量

答：线程局部变量高效地为每个使用它的线程提供单独的线程局部变量值的副本。每个线程只能看到与自己相联系的值，而不知道别的线程可能正在使用或修改它们自己的副本。

* 线程和进程有什么区别？进程间如何通讯，线程间如何通讯

答：
区别：（1）进程是资源分配的最小单位，线程是程序执行的最小单位。<br/>
（2）同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进行至少包括一个线程。<br/>
（4）线程是轻两级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的。<br/>
（5）线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源。<br/>

线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据。进城之间的通信相对复杂，需要借助于一定的通信机制。如：环境变量、命令行参数、管道、有名管道、消息队列、信号量、共享空间、信号、套接字。

* 什么是多线程环境下的伪共享（false sharing）

答：当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。

* 同步和异步有何异同，在什么情况下分别使用他们？举例说明

答：区别：一个需要等待，一个不需要等待

如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。

当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。

### Current

* ConcurrentHashMap 和 Hashtable的区别

答：当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。所以ConcurrentHashMap性能更好。

* ArrayBlockingQueue, CountDownLatch的用法

答：ArrayBlockingQueue是一个由数组支持的有界阻塞队列，在读写操作上都需要锁住整个容器。内部维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时，才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。

CountDownLatch通过一个计数器来实现线程的闭锁，构造器中的计数值（count）就是闭锁需要等待的线程数量，CountDownLatch.await()方法设置线程阻塞，CountDownLatch.countDown()方法将计数值减1，减为0时通知线程继续执行。

* ConcurrentHashMap的并发度是什么

答：并发度（Concurrency Level）即程序运行时能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数，实际上就是ConcurrentHashMap中的分段锁个数，即Segment[]的数组长度。默认的并发度为16。当用户设置并发度时，ConcurrentHashMap会使用大于等于该值的最小2幂指数作为实际并发度。

### CyclicBarrier 和 CountDownLatch有什么不同？各自的内部原理和用法是什么

答：区别：1.CountDownLatch减计数，CyclicBarrier加计数。 
2.CountDownLatch是一次性的，CyclicBarrier可以重用。

CyclicBarrier 允许一组线程互相等待，直到到达某个公共的屏障点，所有线程一起继续执行或者返回。用计数 N 初始化CyclicBarrier, 每调用一次await，线程阻塞，并且计数+1（计数起始是0），当计数增长到指定计数N时，所有阻塞线程会被唤醒。继续调用await也将迅速返回。

### Semaphore的用法

答：Semaphore也是一个线程同步的辅助类，可以维护当前访问自身的线程个数，并提供了同步机制。使用Semaphore可以控制同时访问资源的线程个数，例如，实现一个文件允许的并发访问数。acquire()方法获取许可，在得到许可之前一直被阻塞。release()方法释放一个许可。availablePermits()返回此信号量中当前可用的许可数。 hasQueuedThreads()查询是否有线程正在等待获取。

<a href='https://www.cnblogs.com/liuling/p/2013-8-20-03.html'>资源链接</a>

### Thread

* 启动一个线程是调用 run() 还是 start() 方法？start() 和 run() 方法有什么区别

答：start()。start()方法创建了一个线程，无需等待run()方法中的代码执行完毕，就可以接着执行下面的代码。此时start()的这个线程处于就绪状态，当得到CPU的时间片后就会执行其中的run()方法。

run()方法并没有创建一个线程，调用一个类中的方法，程序中依旧只有一个主线程，必须等到run()方法里面的代码执行完毕，才会继续执行下面的代码，这样就没有达到写线程的目的。

* 调用start()方法时会执行run()方法，为什么不能直接调用run()方法

答：直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征。

* sleep() 方法和对象的 wait() 方法都可以让线程暂停执行，它们有什么区别

答：sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将CPU让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复。

wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池

* yield方法有什么作用？sleep() 方法和 yield() 方法有什么区别

答：使当前处于运行状态的线程放弃CPU，把运行机会让给别的线程。区别：1）sleep()方法给其他线程运行机会时不考虑线程的优先级；yield()方法只会给相同优先级或更高优先级的线程以运行的机会。<br/>
2）线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态。<br/>
3）sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常。<br/>4）sleep()方法比yield()方法具有更好的可移植性。

* Java 中如何停止一个线程

答：使用interrupt方法设置中断状态。使用共享变量的方式给子线程设置标志位关闭子线程。

* stop() 和 suspend() 方法为何不推荐使用

答：stop()方法强行停止线程，会抛出ThreadDeath error，因为此时run()方法可能还未执行完。停止该线程时会释放该线程所持有的所有的锁。导致被保护的数据出现不一致。

suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被"挂起"的线程恢复运行。

* 如何在两个线程间共享数据

答：（1）如果每个线程执行的代码相同，可以使用同一个Runnable对象，这个Runnable对象中有那个共享数据。
（2）如果每个线程执行的代码不同，这时候需要用不同的Runnable对象，可以将共享数据封装成另外一个对象，然后将这个对象逐一传递给各个Runnable对象，每个线程对共享数据的操作方法也分配到那个对象身上完成。

* 如何强制启动一个线程

答：可以使用join（）方法让一个线程强制运行，线程强制运行期间，只有该线程拥有CPU的执行权，其他线程无法运行。

* 如何让正在运行的线程暂停一段时间

答：sleep()、wait()

* 什么是线程组，为什么在Java中不推荐使用

答：在Java中每一个线程都归属于某个线程组管理的一员，例如在主函数main()主工作流程中产生一个线程，则产生的线程属于main这个线程组管理的一员。简单地说，线程组就是由线程组成的管理线程的类，这个类是java.lang.ThreadGroup类。

？？

* 你是如何调用 wait（方法的）？使用 if 块还是循环？为什么

答：wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足。如果采用if判断，当线程从wait中唤醒时，那么将直接执行处理其他业务逻辑的代码，但这时候可能出现另外一种可能，条件谓词已经不满足处理业务逻辑的条件了，从而出现错误的结果，于是有必要进行再一次判断。

### 生命周期
* 有哪些不同的线程生命周期

答：<br/>
新建：创建Thread类的一个实例时，进入新建状态。
就绪：已经被启动，正在等待被分配给CPU时间片，在就绪队列中排队等候。
运行：获得CPU资源正在执行任务。
死亡：执行完毕或被其它线程杀死，线程就进入死亡状态，不可能再进入就绪状态等待执行。
堵塞：由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。

* 线程状态，BLOCKED 和 WAITING 有什么区别

答：阻塞状态是由于外部原因导致本来运行状态的线程让出CPU，进入阻塞队列等待分配锁。而等待状态是线程在就绪队列中排队等候分配CPU。

* 画一个线程的生命周期状态图

答：<img src='http://img.blog.csdn.net/20150627094953213'>

### ThreadLocal 用途是什么，原理是什么，用的时候要注意什么

答：线程局部变量。每个线程创造一个资源的复本,将每一个线程存取数据的行为加以隔离。    
ThreadLocal类中有一个Map，用于存储每一个线程的变量的副本。ThreadLocalMap中元素的key为当前ThreadLocal对象，而value对应线程的变量副本，每个线程可能存在多个ThreadLocal。

### ThreadPool

* 线程池是什么？为什么要使用它

答： 线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。
（1）减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
（2）可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下。

* 如何创建一个Java线程池

答：newSingleThreadExecutor创建一个单线程的线程池。newFixedThreadPool创建固定大小的线程池。
newCachedThreadPool创建一个可缓存的线程池
newScheduledThreadPool创建一个大小无限的线程池。

* ThreadPool用法与优势

答：用法：可以通过ThreadPoolExecutor来创建一个线程池。以使用execute提交的任务，但是execute方法没有返回值，所以无法判断任务是否被线程池执行成功。也可以使用submit 方法来提交任务，它会返回一个future,那么我们可以通过这个future来判断任务是否执行成功，通过future的get方法来获取返回值。可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池，原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程。

优势：第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。

* 提交任务时，线程池队列已满时会发会生什么

答：如果一个任务不能被调度执行那么ThreadPoolExecutor’s submit()方法将会抛出一个RejectedExecutionException异常。

* newCache 和 newFixed 有什么区别？简述原理。构造函数的各个参数的含义是什么，比如 coreSize, maxsize 等

答：newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。

corePoolSize - 池中所保存的线程数，包括空闲线程。

maximumPoolSize - 池中允许的最大线程数。

keepAliveTime - 当线程数大于核心时，多于的空闲线程最多存活时间。

unit - keepAliveTime 参数的时间单位。

workQueue - 当线程数目超过核心线程数时用于保存任务的队列。

hreadFactory - 执行程序创建新线程时使用的工厂。 

* 线程池的实现策略

答：

* 线程池的关闭方式有几种，各自的区别是什么

答：shutdown()、shutdownNow()。
区别：
shutdown:调用之后不允许继续往线程池内继续添加线程；线程池的状态变为SHUTDOWN状态;已经提交的任务继续执行；一旦所有线程结束执行当前任务，ExecutorService才会真正关闭。

shutdownNow:该方法返回尚未执行的 task 的 List；线程池的状态变为STOP状态；阻止所有正在等待启动的任务, 并且停止当前正在执行的任务。

* 线程池中submit() 和 execute()方法有什么区别？

答：sumbit方法返回值是一个Future，可以用这个future来判断任务是否成功完成；execute方法返回值是void型，但无法判断任务是否成功完成。

### 线程调度
* Java中用到的线程调度算法是什么

答：优先级调度算法。

* 什么是多线程中的上下文切换

答：CPU给每个线程分配一个时间片，当一个任务执行一个时间片后会切换到下一个任务，但是切换前会保存上一个任务的状态，以便下次再加载这个任务。从任务保存到再加载的过程就是上下文切换。

* 你对线程优先级的理解是什么

答：每一个线程都是有优先级的，一般来说“高优先级线程”会优先于“低优先级线程”执行。对于需要较多CPU时间的线程需要设置较低的优先级，这样可以确保处理器不会被独占。. 我们可以定义线程的优先级getPriority() setPriority(), 但是这并不能保证高优先级的线程会在低优先级的线程前执行。优先级是一个int变量, 1代表最低, 10代表最高。

* 什么是线程调度器 (Thread Scheduler) 和时间分片 (Time Slicing)

答：每个虚拟机都有一个线程调度器，负责为Runnable状态的线程分配CPU时间, 一旦我们创建一个线程并启动它, 它的执行便依赖于线程调度器的实现。

时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配的CPU时间可以基于线程的优先级或者线程的等待时间, 线程调度并不受到Java虚拟机控制。

### 线程同步
* 请说出你所知的线程同步的方法

答：synchronized同步代码块；同步方法。

* synchronized 的原理是什么

答：每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权。如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。

* synchronized 和 ReentrantLock 有什么不同

答：synchronized是java的关键字；ReentrantLock需要使用lock()和unlock()方法。且等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待。ReentrantLock是公平锁，Synchronized是非公平锁。一个ReentrantLock对象可以同时绑定对个对象。

* 什么场景下可以使用 volatile 替换 synchronized

答：只读操作、只写操作时。

* 有T1，T2，T3三个线程，怎么确保它们按顺序执行？怎样保证T2在T1执行完后执行，T3在T2执行完后执行

答：T3先执行，在T3的run中，调用t2.join，让t2执行完成后再执行t3
在T2的run中，调用t1.join，让t1执行完成后再让T2执行

* 同步块内的线程抛出异常会发生什么

答：线程是会将同步锁释放。

* 当一个线程进入一个对象的 synchronized 方法A 之后，其它线程是否可进入此对象的 synchronized 方法B
 
答：不可以。
 
* 使用 synchronized 修饰静态方法和非静态方法有什么区别

答：synchronized在静态方法上表示调用前要获得类的锁，而在非静态方法上表示调用此方法前要获得对象的锁。

如果使用synchronized来锁定类中所有的同步非静态方法，只需要使用this作为synchronized块的参数传入synchronized块中；在调用静态方法时，对象实例不一定被创建，因此，就不能使用this来同步静态方法，而必须使用Class对象来同步静态方法。

* 如何从给定集合那里创建一个 synchronized 的集合

答：可以使用Collections.synchronizedCollection(Collection c)根据指定集合来获取一个synchronized（线程安全的）集合。

### 锁

* Java Concurrency API 中 的 Lock 接口是什么？对比同步它有什么优势

答：在jdk1.5之后，并发包中新增了Lock接口(以及相关实现类)用来实现锁功能，Lock接口提供了与synchronized关键字类似的同步功能，但需要在使用时手动获取锁和释放锁。

优势：（1）可以使锁更公平；（2）
可以使线程在等待锁的时候响应中断；（3）
可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间；（4）
可以在不同的范围，以不同的顺序获取和释放锁

* Lock 与 Synchronized 的区别？Lock 接口比 synchronized 块的优势是什么

答：区别：（1）Lock是个接口，Synchronized是关键字。<br/>
（2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁。<br/>
（3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断。<br/>
（4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。<br/>
（5）Lock可以提高多个线程进行读操作的效率。

* ReadWriteLock是什么？

答：读写锁。当程序对一些共享资源进行读和写操作时，如果有一个线程想去写这些共享资源，就不应该再有其它线程对该资源进行读或写。只要没有线程拥有写锁，且没有线程在请求写锁，所有想获得读锁的线程都能成功获取。当没有线程持有读锁,且没有线程持有写锁时就能获得写锁。

* 锁机制有什么用

答：多个线程访问同一个共享资源时维护数据一致性。

* 什么是乐观锁（Optimistic Locking）？如何实现乐观锁？如何避免ABA问题

答：乐观锁：当去做某个修改或其他操作的时候它认为不会有其他线程来做同样的操作。

如何实现：CAS(Compare and Swap 比较并交换)，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。冲突检查，数据更新。

ABA问题：从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。标志就是版本戳。引用计数、序列号

* 解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁

答：重排序：编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。

自旋锁：只是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁。

偏向锁：锁偏向于第一个获得它的线程。如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。

轻量级锁：线程在执行同步块之前， JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，然后线程尝试使用 CAS 将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。

可重入锁：同一个线程再次进入同步代码的时候.可以使用自己已经获取到的锁，这就是可重入锁。

公平锁：加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得。

非公平锁：加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待。

乐观锁：每次读数据的时候都认为别人不会修改，所以不会上锁。每次写数据的时候通过CAS操作，比较当前值跟传入值是否一样，一样则更新，否则失败。

悲观锁：每次读数据的时候都认为别人会修改，所以读写数据都会上锁。这样别人想读写这个数据就会block直到拿到锁。如：Synchronized、RetreenLock。

如果冲突很少，或者冲突的后果不会很严重，那么通常情况下应该选择乐观锁，因为它能得到更好的并发性，而且更容易实现。但是，如果冲突的结果对于用户来说痛苦的，那么就需要使用悲观策略。

* 什么时候应该使用可重入锁

答：当出现递归调用时，调用同一对象其它synchronized或者有同步锁函数时。

* 简述锁的等级方法锁、对象锁、类锁

答：
对象锁：当一个对象中有synchronized method或synchronized block的时候调用此对象的同步方法或进入其同步区域时，就必须先获得对象锁。

类锁：由于一个class不论被实例化多少次，其中的静态方法和静态变量在内存中都只有一份。所以，一旦一个静态的方法被申明为synchronized。此类所有的实例化对象在调用此方法，共用同一把锁，我们称之为类锁。 

方法锁：通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。每个synchronized方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞。方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放。

* Java中活锁和死锁有什么区别？

答：死锁：一个线程需要获取多个资源的时候，这时由于两个线程互相等待对方的资源而被阻塞。

活锁：线程不断重复执行相同的操作，但每次操作的结果都是失败的。

* 什么是死锁(Deadlock)？导致线程死锁的原因？如何确保 N 个线程可以访问 N 个资源同时又不导致死锁

答：一个线程需要获取多个资源的时候，这时由于两个线程互相等待对方的资源而被阻塞。

原因：资源竞争、循环等待、部分分配、缺少优先权。

指定锁的顺序，并强制线程按照指定的顺序获取锁。因此所有的线程都是以同样的加锁和释放锁，就不会出现死锁了

* 死锁与活锁的区别，死锁与饥饿的区别

答：活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。

死锁与饥饿的区别：死锁进程都处于等待态，饿死进程可能处于忙式等待；死锁进程发生了循环等待，而饥饿不会；死锁一定是多个进程，饥饿可能只有一个进程。

* 怎么检测一个线程是否拥有锁

答：java.lang.Thread中有一个方法叫holdsLock(Object o)，如果当且仅当当前线程拥有某个具体对象的锁它返回true

* 如何实现分布式锁

答：基于数据库实现分布式锁

基于缓存（redis，memcached，tair）实现分布式锁

基于Zookeeper实现分布式锁

* 有哪些无锁数据结构，他们实现的原理是什么

答：ConcurrentLinkedQueue，一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现。

[资料链接](http://ifeve.com/concurrentlinkedqueue/)

* 读写锁可以用于什么应用场景

答：在多线程的环境下，对同一份数据进行读写，会涉及到线程安全的问题。比如在一个线程读取数据的时候，另外一个线程在写数据，而导致前后数据的不一致性；一个线程在写数据的时候，另一个线程也在写，同样也会导致线程前后看到的数据的不一致性。

### Executors类是什么？ Executor和Executors的区别

答：Executors 是一个工具类，类似于 Collections。提供工厂方法来创建不同类型的线程池，比如 FixedThreadPool 或 CachedThreadPool。

区别：Executor是Java线程池的顶级接口，Executors是一个类；Executor提供了execute()接口来执行已提交的 Runnable 任务的对象。

### 什么是Java线程转储(Thread Dump)，如何得到它

答：线程转储是一个JVM活动线程的列表，记录了在某一个给定的时刻运行的所有线程的快照，它对于分析系统瓶颈和死锁非常有用。 可以使用jstack。

### 如何在Java中获取线程堆栈

答：Windows你可以使用Ctrl + Break组合键来获取线程堆栈，Linux下用kill -3命令，也可以用jstack这个工具来获取。

### 说出 3 条在 Java 中使用线程的最佳实践

答：

### 在线程中你怎么处理不可捕捉异常

答：Thread对象提供的setUncaughtExceptionHandler方法。通过该方法给某个thread设置一个UncaughtExceptionHandler，可以确保在该线程出现异常时能通过回调UncaughtExceptionHandler接口的void uncaughtException(Thread t, Throwable e) 方法来处理异常。

### 请说出与线程同步以及线程调度相关的方法

答：wait()等待、sleep()睡眠、notify()唤醒一个等待的线程、notifyAll()唤醒所有处于等待的线程、Lock接口

### 程序中有3个 socket，需要多少个线程来处理

答：3个。

### 如何在 Windows 和 Linux 上查找哪个线程使用的 CPU 时间最长

答：jps top -H -p pid

### 如何确保 main() 方法所在的线程是 Java 程序最后结束的线程

答：可以使用Thread类的join()方法来确保所有程序创建的线程在main()方法退出前结束。

### 你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它

答：读写锁，ReadWriteLock。

## 对象

### 拷贝(clone)
* 如何实现对象克隆

答：需要被克隆的对象首先实现Cloneable接口，调用clone方法复制对象。

* 深拷贝和浅拷贝区别

答：区别在于是否支持引用类型的成员变量的复制。浅克隆对于引用类型的对象仅仅是复制了地址并没有在内存中开辟一块新的空间。

* 深拷贝和浅拷贝如何实现激活机制

答：

* 写clone()方法时，通常都有一行代码，是什么

答：super.clone()

### 比较

* 在比较对象时，"==" 运算符和 equals 运算有何区别

答：“==”比较两个对象时，是比较两个对象使用的内存地址和内容是否相同，equals()方法比较两个对象时，则是比较两个对象的内容是否相同，而与对象的内存地址无关。

　1）对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；如果作用于引用类型的变量，则比较的是所指向的对象的地址

　2）对于equals方法，注意：equals方法不能作用于基本数据类型的变量,如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。

* 如果要重写一个对象的equals方法，还要考虑什么

答：还需要重写hashCode()方法。保证(1)当obj1.equals(obj2)为true时，obj1.hashCode() == obj2.hashCode()必须为true 
(2)当obj1.hashCode() == obj2.hashCode()为false时，obj1.equals(obj2)必须为false

* 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对

答：不对。

### 构造器
* 构造器链是什么

答：在继承关系中，通过new指令启动了子类的构造器，在子类构造器中，编译器会自动添加默认super()方法，通过super()方法调用了父类构造器。这个过程就是构造器链。

* 创建对象时构造器的调用顺序

答：1、首先调用基类的构造方法，如果有多层继承现象，则会首先构造这个结构的根，然后向下构造直到最底层导出类。 
2、按照方法内域的声明顺序调用成员的初始化方法。 
3、调用导出类构造方法

### 不可变对象
* 什么是不可变对象（immutable object）

答：是创建后不可以改变的对象，典型的例子就是Java中的String类。

* 为什么 Java 中的 String 是不可变的（Immutable）

答：(1）字符串池（String pool）的需求 在Java中，当初始化一个字符串变量时，如果字符串已经存在，就不会创建一个新的字符串变量，而是返回存在字符串的引用。

(2)缓存字符串hashcode码的需要 字符串的hashcode是经常被使用的，字符串的不变性确保了hashcode的值一直是一样的，在需要hashcode时，就不需要每次都计算，这样会很高效。

(3)出于安全性考虑 字符串经常作为网络连接、数据库连接等参数，不可变就可以保证连接的安全性。 

* 如何构建不可变的类结构？关键点在哪里

答：(1)将类声明为final (2)将所有的成员声明为私有的 (3)对变量不要提供setter方法 (4)将所有可变的成员声明为final，这样只能对它们赋值一次 (5)通过构造器初始化所有成员，进行深拷贝(deep copy) (6)
在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝

* 能创建一个包含可变对象的不可变对象吗

答：可以，但是不可暴露该对象的引用，需要返回该对象时返回一个该对象的克隆。

### 如何对一组对象进行排序

答：Collections.sort(List ,new Comparator<>(){});

### 数组复制效率

答：System.arraycopy > clone > Arrays.copyOf > for循环

## 方法

### 构造器（constructor）是否可被重写（override）

答：不可以被继承，所以不可以被重写。

### 方法可以同时即是 static 又是 synchronized 的吗

答：可以。

### abstract 的 method是否可同时是 static，是否可同时是 native，是否可同时是synchronized

答：可以，可以，不可以。

### Java支持哪种参数传递类型

答：值传递。

### 一个对象被当作参数传递到一个方法，是值传递还是引用传递

答：值传递。

### 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递

答：值传递。

### 我们能否重载main()方法

答：能。

### 如果main方法被声明为private会怎样

答：能编译通过，但是无法运行。

## 异常

### 基本概念
* Error 和 Exception有什么区别

答：Error：表示由 JVM 所侦测到的无法预期的错误，由于这是属于 JVM 层次的严重错误 ，导致 JVM 无法继续执行，因此，这是不可捕捉到的，无法采取任何恢复的操作，顶多只能显示错误信息。

Exception：表示可恢复的例外，这是可捕捉到的。 

* UnsupportedOperationException是什么

答：由于非法操作而导致的异常，如：对固定大小的List添加超过个数的元素。

* NullPointerException 和 ArrayIndexOutOfBoundException 之间有什么相同之处

答：这两个异常都是非检查型异常，都继承自RuntimeException。

* 什么是受检查的异常，什么是运行时异常

答：除了runtimeException以外的异常，都属于checkedException，Java编译器要求程序必须捕获或声明抛出这种异常。如IOException

不需要编译器来检测，可以在运行时抛出。程序中可以选择捕获处理，也可以不处理。

* 运行时异常与一般异常有何异同

答：一般异常需要被捕获或申明抛出，而运行时异常不用；运行时异常是不可预见的，一般异常是可以预见的。

* 简述一个你最常见到的runtime exception(运行时异常)

答：NullPointerException、IndexOutOfBoundsException。

### finally
* finally关键词在异常处理中如何使用

答：finally关键字用于try后面，finally块中的代码总是执行，不论是否发生异常。一般用于清理工作、关闭链接等类型的语句。

* 如果执行finally代码块之前方法返回了结果，或者JVM退出了， finally块中的代码还会执行吗

答：在执行finally之前先返回结果，finally块还是会执行。如果JVM推出如System.exit()，finally块就不会执行了。

* try里有return，finally还执行么？那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后

答：会，return之前。

* 在什么情况下，finally语句不会执行

答：在try块或者catch块中调用了退出虚拟机的方法（即System.exit(1);）。在try之前就return了。多线程情况下，一个线程在try或catch时被kill掉了。

### throw 和 throws 有什么区别？

答：方法内部throw抛出一个异常；throws方法可能抛出异常的申明。

### OOM(OutofMemory)如何解决？

答：除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM)异常的可能。java堆用于存储对象实例，只要不断的创建对象，并且GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。

通过内存映像分析工具对内存快照进行分析，判断是内存泄漏还是内存溢出，如果是溢出可调整JVM参数如-Xmx与-Xms。如果是泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，就能好找到是如何导致GC无法收回。

### SOF(Stackoverflow)

答：如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。

### 既然我们可以用RuntimeException来处理错误，那么你认为为什么Java中还存在检查型异常

答：（1）为了程序设计的优美。（2）可以使用try、catch、finally来保护某些对异常敏感的程序。

### 当自己创建异常类的时候应该注意什么

答：自定义异常需要继承Exception。

### 导致空指针异常的原因

答：（1）当在栈区声明了引用类型的变量，而未让该引用变量指向堆区的内存时（即只声明未初始化），再操作该引用变量则出空指针错。

（2）既声明又初始化了引用变量，但操作该引用变量的语句的作用域 不在 声明该引用变量的语句的作用域内。

### 异常处理 handle or declare 原则应该如何理解

答：

### 怎么利用 JUnit 来测试一个方法的异常

答：@Test(expected=Exception.class)

fail(“No Exception thrown.”) 

### catch块里不写代码有什么问题

答：

### 你曾经自定义实现过异常吗？怎么写的

### 什么是 异常链

答：常常会在捕获一个异常后抛出另外一个异常，并且希望把异常原始信息保存下来，这被称为异常链。

### 在try块中可以抛出异常吗

答：可以，会被catch语句捕获住。

## IO

### File
* File类型中定义了什么方法来创建一级目录

答：java.io.File.mkdir()。

* File类型中定义了什么方法来判断一个文件是否存在

答：java.io.File.exists()。

### 流

* 为了提高读写性能，可以采用什么流

答：BufferedInputStream、BufferedOutputStream

* Java中有几种类型的流

答：一种是字节流，另一种是字符流。

* JDK 为每种类型的流提供了一些抽象类以供继承，分别是哪些类

答：Java中的流分为两种，一种是字节流，另一种是字符流，分别由四个抽象类来表示:InputStream，OutputStream，Reader，Writer。

* 对文本文件操作用什么I/O流

答：FileInputStream和FileOutputStream文件流类，是InputStream，OutputStream的子类。

* 对各种基本数据类型和String类型的读写，采用什么流
能指定字符编码的 I/O 流类型是什么

答：采用DataInputStream、DataOutputStream，能指定编码的是 InputStreamReader、OutputStreamWriter

### 序列化
* 什么是序列化？如何实现 Java 序列化及注意事项

答：Java对象的序列化指将一个java对象写入OI流中，与此对应的是，对象的反序列化则从IO流中恢复该java对象。

如果要让某个对象支持序列化机制，则必须让它的类是可序列化的，为了让某个类是可序列化的，该类必须实现Serializable接口或Externalizable接口

* Serializable 与 Externalizable 的区别

答：被Serializable接口声明的类的对象的内容都将被序列化；而实现Externalizable接口的类可以指定序列化的内容。

Serializable实现简单，Java对其有内建支持；Externalizable实现复杂，由开发人员自己完成。

Serializable所有对象由Java统一保存，性能较低；Externalizable开发人员决定哪个对象保存，可能提升速度。

### Socket

* socket 选项 TCP NO DELAY 是指什么

答：禁用Nigle算法。防止出现write-write-read现象。

[资料链接](https://blog.csdn.net/u014532901/article/details/78573261)

* Socket 工作在 TCP/IP 协议栈是哪一层

答：传输层

* TCP、UDP 区别及 Java 实现方式

答：
区别：（1）TCP是面向连接的协议，而UDP是无连接的协议。
（2）TCP保证可靠传输，UDP不保证可靠传输。
（3）TCP也保证了消息的有序性，UDP不提供任何有序性或序列性的保证。
（4）TCP不保存数据的边界，而UDP保证。
（5）TCP速度比较慢，而UDP速度比较快。
（6）TCP是重量级的协议，而UDP协议则是一个轻量级的协议。
（7）TCP具有比UDP更大的头。TCP数据包报头的大小是20字节，UDP数据报报头是8个字节。

Java：Socket类用的传输层协议为TCP、DatagramSocket类传输层协议使用UDP。

### 说几点 IO 的最佳实践

答：

### 直接缓冲区与非直接缓冲器有什么区别？

答：直接缓存区是在虚拟机内存外，开辟的内存，IO操作直接进行，不再对其进行复制，但创建和销毁开销大；非直接缓存区在虚拟机内存中创建，易回收，但占用虚拟机内存开销，处理中有复制过程。

### 怎么读写 ByteBuffer？ByteBuffer 中的字节序是什么

答：ByteBuffer get(byte [] dst)。

字节序是指存放多字节数据的字节（byte）的顺序，可以用order方法来取得和设置字节序。

### 当用System.in.read(buffer)从键盘输入一行n个字符后，存储在缓冲区buffer中的字节数是多少

答：n+2个(除了n个字符还有回车和换行字符)

### 如何使用扫描器类（Scanner Class）令牌化

答：令牌化是指在分隔符的基础上将一个字符串分割为若干个子字符串。Scanner.useDelimiter(分隔符);

## 面向对象

## 设计模式

